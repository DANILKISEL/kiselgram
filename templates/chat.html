<!-- templates/chat.html -->
{% extends "base.html" %}

{% block content %}
<div class="mobile-app">
    <!-- Header -->
    <div class="header safe-area-top">
        <button class="header-button ripple" onclick="goBack()">â†</button>
        <div class="chat-user-info" style="flex: 1; display: flex; align-items: center; gap: 12px;">
            <div class="chat-avatar" style="width: 40px; height: 40px; font-size: 16px;">
                {{ receiver.username[0]|upper }}
            </div>
            <div>
                <div class="chat-name" style="font-size: 16px; font-weight: 500;">{{ receiver.username }}</div>
                <div class="chat-status" style="font-size: 13px; color: var(--online-status);">online</div>
            </div>
        </div>
        <button class="header-button ripple">â‹®</button>
    </div>

    <!-- Messages -->
    <div class="chat-view">
        <div class="messages-container" id="messagesContainer">
            <div class="loading">
                <div class="spinner"></div>
            </div>
        </div>

        <!-- Input Area -->
        <div class="input-area">
            <form class="input-form" id="messageForm">
                <textarea class="message-input" placeholder="Message" id="messageInput"
                         rows="1" required></textarea>
                <button type="submit" class="send-button ripple" id="sendButton">â¤</button>
            </form>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- In the scripts section of templates/chat.html -->
<script>
const receiverId = {{ receiver.id }};
let isSending = false;
let lastMessageId = 0;

function goBack() {
    window.history.back();
}

// Load messages when page loads
document.addEventListener('DOMContentLoaded', function() {
    loadMessages();
    setupMessageInput();
});

async function loadMessages() {
    try {
        const response = await fetch(`/api/messages/${receiverId}`);
        const data = await response.json();

        const container = document.getElementById('messagesContainer');

        if (data.messages && data.messages.length > 0) {
            // Get current last message ID to check if we have new messages
            const currentLastId = data.messages[data.messages.length - 1].id;

            if (currentLastId > lastMessageId) {
                // Only update if we have new messages
                container.innerHTML = '';
                data.messages.forEach(message => {
                    const messageDiv = createMessageElement(message, false); // No animation for existing messages
                    container.appendChild(messageDiv);
                });
                scrollToBottom();
                lastMessageId = currentLastId;
            }
        } else {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ğŸ’¬</div>
                    <div class="empty-state-text">No messages yet</div>
                    <div class="empty-state-subtext">Send a message to start the conversation!</div>
                </div>
            `;
        }
    } catch (error) {
        console.error('Error loading messages:', error);
    }
}

function createMessageElement(message, animate = false) {
    const div = document.createElement('div');
    div.className = `message ${message.is_own ? 'outgoing' : 'incoming'}`;
    div.dataset.messageId = message.id;

    if (animate) {
        div.classList.add('bounce-in');
    }

    div.innerHTML = `
        <div class="message-bubble">
            <div class="message-text">${escapeHtml(message.content)}</div>
            <div class="message-time">
                ${message.timestamp}
                ${message.is_own ? `<span class="message-status">${message.is_read ? 'âœ“âœ“' : 'âœ“'}</span>` : ''}
            </div>
        </div>
    `;

    return div;
}

function setupMessageInput() {
    const input = document.getElementById('messageInput');
    const form = document.getElementById('messageForm');
    const container = document.getElementById('messagesContainer');

    // Auto-resize textarea
    input.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 120) + 'px';
    });

    // Form submission
    form.addEventListener('submit', async function(e) {
        e.preventDefault();

        if (isSending) return;

        const content = input.value.trim();
        if (!content) return;

        isSending = true;

        // Create optimistic UI update
        const tempId = 'temp-' + Date.now();
        const tempMessage = {
            id: tempId,
            content: content,
            sender_name: '{{ current_user }}',
            timestamp: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
            is_own: true,
            is_read: false
        };

        // Add message immediately to UI
        addMessageToUI(tempMessage, true);
        input.value = '';
        input.style.height = 'auto';

        // Then send to server
        await sendMessage(content, tempId);
        isSending = false;
    });
}

async function sendMessage(content, tempId) {
    try {
        const response = await fetch('/api/send_message', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                receiver_id: receiverId,
                content: content
            })
        });

        const data = await response.json();

        if (data.success) {
            // Remove temporary message and add the real one
            removeTempMessage(tempId);
            addMessageToUI(data.message, true);
            lastMessageId = data.message.id;
        } else {
            // Show error and keep temporary message
            showMessageError(tempId);
        }
    } catch (error) {
        console.error('Error sending message:', error);
        showMessageError(tempId);
    }
}

function addMessageToUI(message, animate = false) {
    const container = document.getElementById('messagesContainer');

    // Remove empty state if it exists
    const emptyState = container.querySelector('.empty-state');
    if (emptyState) {
        emptyState.remove();
    }

    const messageDiv = createMessageElement(message, animate);
    container.appendChild(messageDiv);
    scrollToBottom();
}

function removeTempMessage(tempId) {
    const tempMessage = document.querySelector(`[data-message-id="${tempId}"]`);
    if (tempMessage) {
        tempMessage.remove();
    }
}

function showMessageError(tempId) {
    const tempMessage = document.querySelector(`[data-message-id="${tempId}"]`);
    if (tempMessage) {
        tempMessage.classList.add('shake');
        const bubble = tempMessage.querySelector('.message-bubble');
        bubble.style.background = '#ffebee';
        bubble.style.color = '#c62828';

        // Restore after 2 seconds
        setTimeout(() => {
            tempMessage.classList.remove('shake');
            bubble.style.background = '';
            bubble.style.color = '';
        }, 2000);
    }
}

function scrollToBottom() {
    const container = document.getElementById('messagesContainer');
    setTimeout(() => {
        container.scrollTop = container.scrollHeight;
    }, 100);
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Poll for new messages (only load unseen ones)
setInterval(async () => {
    try {
        const response = await fetch(`/api/messages/${receiverId}?after=${lastMessageId}`);
        const data = await response.json();

        if (data.messages && data.messages.length > 0) {
            data.messages.forEach(message => {
                // Only add messages we haven't seen yet
                if (message.id > lastMessageId) {
                    addMessageToUI(message, true); // Animate new incoming messages
                    lastMessageId = message.id;
                }
            });
        }
    } catch (error) {
        console.error('Error polling messages:', error);
    }
}, 2000);
</script>
{% endblock %}